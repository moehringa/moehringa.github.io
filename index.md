---
title: Document Center
---

##### the_Blog_

###ONE
* What Software Engineering Means to Me...
  * Software Engineering is the design, building, and ultimately creation of
  tools that can be used to enhance or boost the performance and/or quality of
  what they are being applied to.  Take for instance recommendation algorithms.  
  These algorithms raise the quality of the system to which they are applied by
  making recommendations or items to its users that they may not have know about
  otherwise.  The Software Engineering was the design and subsequent problem
  solving that took place to make automated relevant recommendations a reality.
  The engineers get to be the creators, making something from nothing, or redesigning
  an already existing project.  

###TWO
* _The Pragmatic Programmer_ Chapter 1...
  * During chapter one, the authors stressed the importance of being interactive
  within the working community, and communicating effectively with colleagues as
  well as clients.  One part that stuck out was "Good-Enough Software."  I know
  that its very easy to go somewhat overboard when finishing programs sometimes.
  Often more features are considered better when it may be true that by adding
  more we can actually be taking away from a program.  Good-Enough, it was stated,
  does not necessarily imply shoddy, but a product that works and does the job
  reliably.  
  * Another part I found interesting was the section when the author brought up
  the "broken windows" metaphor, and how important it is to pay attention to
  detail.  Although leaving something out or not fully refining a small detail
  may save a little time or energy, that small detail may imply a larger problem
  and snowball into more headaches down the road.  Having unfinished, or less than
  adequate pieces also gives off the impression that you may not care about the
  project, position, or job.
  * Finally, reading some of the timelines such as "read a technical book once per
  quarter," and "learn a new language each year" were good to give an idea of the
  expectations in the industry.  Also to start learning the new language this week
  was good as its easy to put it off and make the excuse of being to busy all of
  the time.  
  
   ###3
* _The Pragmatic Programmer_ Chapter 2...
  * In this chapter I noticed, after the information on duplicating code, the advice on setting up a forum or area in which developers could discuss problems and ideas.  Although this has been brought up in many of my classes I don't believe we (the students) have ever actually implemented this successfully. 
  * I found the tracer code section to be interesting, in that as soon as you believe you can successfully begin to distribute or implement something, likely after prototyping, the best thing to do is likely to begin implementing it.  This way the feedback begins to come back as soon as possible.  This also opens up the lines for communication which was brought up in chapter one.
  *Another piece of advice I found helpful was to not give out quick estimates, they may come back to haunt you.  If for instance you give a fairly optimistic estimate but then find the problem to be a little more difficult than expected you may well have dug yourself into a hole that could have been avoided by using a slightly longer estimate.
  
   ###4
* _The Pragmatic Programmer_ Chapter 3...
  * The first concept that struck my attention in this chapter was to find an editor to write code in and get well acquainted with it.  The more well versed on can be with their machine, the better equipped they are to trim excess work or inefficiencies out of their load.  This is one area in which I can definitely improve upon, especially using keyboard shortcuts rather than meandering around with the mouse or trackpad all the time.  This also gives more reason to learn to use a powerful IDE well since it has to the potential to be a very powerful tool.  Another concept was that of text manipulation languages.  Im not sure I understood this concept all that well but it seemed as though a language such as Perl or Python could be used to generate the same amount of code that may take upwards of 100 lines in C in less than 20 lines.  I have heard that scripting languages such as Python are slower so although they may be quicker to write prototypes in, when it comes time to deploy the final product they are then written in C++ or the like.  This is an interesting topic to continue or look further into.
